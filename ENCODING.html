<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Megapad-64 Instruction Encoding Specification v0.1</title>
<style>
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;line-height:1.55;margin:0;padding:0 1rem 3rem;background:#f6f8fb;color:#1b1e23;max-width:1100px;margin:auto}
h1,h2,h3,h4{font-weight:600;color:#0d1117;margin:2rem 0 1rem}
h1{font-size:2rem;border-bottom:3px solid #3a5bff;padding-bottom:.5rem;margin-top:1.5rem}
h2{font-size:1.4rem;border-bottom:2px solid #d0d7de;padding-bottom:.3rem}
h3{font-size:1.15rem}
h4{font-size:1.05rem;color:#24292f}
table{width:100%;border-collapse:collapse;margin:1rem 0;font-size:.88rem}
th,td{border:1px solid #d0d7de;padding:.35rem .55rem;text-align:left;vertical-align:top}
thead th{background:#e6edf3}
code,pre{font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,monospace;font-size:.82rem}
pre{background:#0d1117;color:#e6edf3;padding:1rem;border-radius:6px;overflow:auto}
aside.note{background:#fff9c4;border-left:4px solid #f5c940;padding:.75rem;margin:1.25rem 0}
aside.tip{background:#e6f7ea;border-left:4px solid #46c36f;padding:.75rem;margin:1.25rem 0}
aside.warn{background:#ffe0e0;border-left:4px solid #d93025;padding:.75rem;margin:1.25rem 0}
.bit-diagram{font-family:monospace;font-size:.9rem;background:#0d1117;color:#c9d1d9;padding:.6rem 1rem;border-radius:6px;overflow-x:auto;white-space:pre}
.bit-diagram .field{color:#58a6ff;font-weight:bold}
.bit-diagram .sep{color:#484f58}
ul,ol{margin:.4rem 0 .8rem 1.2rem}
li{margin:.2rem 0}
</style>
</head>
<body>

<h1>Megapad-64 Instruction Encoding Specification<br>
<span style="font-weight:400;font-size:1.1rem">v0.1 — Spiritual Successor to the RCA&nbsp;1802 COSMAC</span></h1>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="philosophy">0 Design Philosophy: Honouring the 1802</h2>

<aside class="note">
<strong>The RCA 1802 encoding in one sentence:</strong> every instruction is a single byte split into a
4-bit opcode family <code>I</code> (high nibble) and a 4-bit operand/selector <code>N</code> (low nibble), with
16 general-purpose 16-bit registers addressed by <code>N</code>, <code>P</code> (program counter designator), or
<code>X</code> (data-pointer designator). Subroutines are called by switching which register is the PC
(<code>SEP&nbsp;Rn</code>). Immediates and branch targets are inline bytes fetched via <code>R(P)</code>.
</aside>

<p>The Megapad-64 encoding preserves these 1802 principles while scaling to 64&nbsp;bits:</p>

<table>
<thead><tr><th>1802 Principle</th><th>Megapad-64 Equivalent</th><th>Rationale</th></tr></thead>
<tbody>
<tr>
  <td><code>I|N</code> — 4-bit family + 4-bit selector in one byte</td>
  <td>Primary byte is always <code>FFFF|NNNN</code>: 4-bit family <code>F</code> + 4-bit register/sub-op <code>N</code></td>
  <td>A decoder can identify the instruction family from the top nibble alone, exactly like the 1802.</td>
</tr>
<tr>
  <td>Most instructions are 1 byte</td>
  <td>Register-only ops are 1 byte (family + 1 register) or 2 bytes (family + 2 registers packed <code>Rd|Rs</code>).
      Immediate ops append 1–8 bytes inline. The <code>EXT</code> prefix adds 1 byte of overhead.</td>
  <td>Keeps code density high and decode simple. Prefix byte is the modern equivalent of the 1802's
      3-cycle "long" instructions.</td>
</tr>
<tr>
  <td><code>P</code> designator selects which register is PC; <code>SEP Rn</code> to call</td>
  <td><code>PSEL</code> CSR (4 bits) designates which R0–R15 is PC. <code>SEP Rn</code> instruction preserved.
      Also: a hardware <code>CALL</code>/<code>RET</code> pair for modern toolchain convenience.</td>
  <td>Retains the 1802's unique register-as-PC model. <code>CALL</code>/<code>RET</code> are sugar that use <code>SPSEL</code>-based stack.</td>
</tr>
<tr>
  <td><code>X</code> designator selects which register is the data pointer</td>
  <td><code>XSEL</code> CSR (4 bits) designates which R0–R15 is the data pointer for indirect memory ops.
      <code>SEX Rn</code> instruction preserved.</td>
  <td>Memory loads/stores via <code>R(X)</code> mirror the 1802's architecture exactly, but on 64-bit addresses.</td>
</tr>
<tr>
  <td><code>D</code> accumulator — all ALU through one register</td>
  <td>Direct register-to-register ALU (modern path) <em>plus</em> an <code>R(X)</code>-indirect ALU mode
      that mirrors the 1802's <code>M(R(X)) op D → D</code></td>
  <td>Keeps the spirit of the 1802's simple datapath while adding the register-to-register path
      modern compilers expect.</td>
</tr>
<tr>
  <td>Short branch = 2 bytes (cond + 8-bit page-relative);<br>Long branch = 3 bytes (cond + 16-bit absolute)</td>
  <td>Short branch = 2 bytes (cond + signed 8-bit PC-relative offset);<br>
      Long branch = 3 bytes (cond + signed 16-bit PC-relative offset);<br>
      Full branch = EXT prefix + 8-byte absolute address.</td>
  <td>Mirrors the 1802 short/long branch split. PC-relative replaces page-relative for modern use.
      The 1802's "page" concept doesn't scale to 64-bit addresses.</td>
</tr>
<tr>
  <td>Inline immediate data at R(P); PC auto-advances</td>
  <td>Immediate bytes follow the instruction word; PC auto-advances past them, exactly as on the 1802.</td>
  <td>Same mechanism, same simplicity.</td>
</tr>
<tr>
  <td><code>MARK</code>/<code>SAV</code>/<code>RET</code>/<code>DIS</code> for saving and restoring X/P</td>
  <td><code>MARK</code> pushes <code>PSEL|XSEL</code> to stack; <code>RET</code> pops them and re-enables interrupts;
      <code>DIS</code> pops them and disables interrupts.</td>
  <td>Direct spiritual mapping. The T register concept becomes a PUSH/POP of the designator pair.</td>
</tr>
<tr>
  <td>DMA via R(0), interrupt via R(1)</td>
  <td>DMA pointer alias <code>DP</code> defaults to R2 (configurable). Interrupt entry uses <code>IVT_BASE</code> vector table but
      hardware auto-saves <code>PSEL|XSEL</code> à la the 1802's T register save.</td>
  <td>R(0)/R(1) hard-assignment was an 1802 limitation; Megapad makes it configurable while
      keeping the same DMA-pointer concept.</td>
</tr>
</tbody>
</table>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="format">1 Instruction Format Overview</h2>

<p>Every instruction begins with a single <strong>primary byte</strong>:</p>

<div class="bit-diagram">
  Bit:   7  6  5  4 │ 3  2  1  0
       ┌──┬──┬──┬──┼──┬──┬──┬──┐
       │ F3  F2  F1  F0 │ N3  N2  N1  N0 │
       └──┴──┴──┴──┼──┴──┴──┴──┘
         Family (F)  │  Operand (N)
</div>

<p>The <strong>F</strong> nibble (bits 7–4) selects one of 16 opcode families. The <strong>N</strong> nibble (bits 3–0)
carries a register index, sub-function code, or condition code — exactly as the 1802's <code>I|N</code> split.</p>

<p>Depending on the family, zero or more <strong>extension bytes</strong> follow:</p>

<table>
<thead><tr><th>Instruction Shape</th><th>Total Bytes</th><th>Example</th></tr></thead>
<tbody>
<tr><td>Single-byte (family + N only)</td><td>1</td><td><code>INC Rn</code>, <code>DEC Rn</code>, <code>SEP Rn</code>, <code>SEX Rn</code>, <code>NOP</code></td></tr>
<tr><td>Two-register (byte 2 = <code>Rd|Rs</code>)</td><td>2</td><td><code>ADD Rd, Rs</code>, <code>MOV Rd, Rs</code>, <code>CMP Rd, Rs</code></td></tr>
<tr><td>Register + imm8</td><td>2–3</td><td><code>LDI Rn, imm8</code>, <code>ADDI Rn, imm8</code>, <code>BR.cond offset8</code></td></tr>
<tr><td>Register + imm16</td><td>3–4</td><td><code>LBR.cond offset16</code>, <code>LHI Rn, imm16</code></td></tr>
<tr><td>EXT-prefixed + imm64</td><td>2 + 8 = 10</td><td><code>EXT LDI Rn, imm64</code></td></tr>
<tr><td>MEX tile ops</td><td>1–3</td><td><code>TALU.ADD</code>, <code>TMUL.DOT</code>, <code>TSYS.TRANS</code></td></tr>
</tbody>
</table>

<aside class="tip">
<strong>Decoder rule (1802-style):</strong> The top nibble <code>F</code> of byte 0 uniquely determines how many
additional bytes the instruction consumes. No variable-length ambiguity — the decoder fetches
exactly the documented count after reading byte 0.
</aside>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="designators">2 Designator Registers: PSEL, XSEL, SPSEL</h2>

<p>The 1802's <code>P</code> and <code>X</code> designators are preserved as first-class architectural features:</p>

<table>
<thead><tr><th>CSR</th><th>Bits</th><th>Reset</th><th>Purpose</th></tr></thead>
<tbody>
<tr><td><code>PSEL</code></td><td>4</td><td>3</td>
    <td>Designates which GPR (R0–R15) is the <strong>program counter</strong> <code>R(P)</code>.
        Equivalent to the 1802's <code>P</code> register.</td></tr>
<tr><td><code>XSEL</code></td><td>4</td><td>2</td>
    <td>Designates which GPR is the <strong>data pointer</strong> <code>R(X)</code> for indirect memory ops.
        Equivalent to the 1802's <code>X</code> register.</td></tr>
<tr><td><code>SPSEL</code></td><td>4</td><td>15</td>
    <td>Designates which GPR is the <strong>stack pointer</strong> <code>SP</code> for PUSH/POP/CALL/RET.
        New to Megapad (the 1802 used R2 by convention).</td></tr>
</tbody>
</table>

<h3>2.1 SEP and SEX Instructions</h3>
<pre><code>SEP Rn   ;  N → PSEL   (switch program counter to Rn — the 1802 CALL mechanism)
SEX Rn   ;  N → XSEL   (switch data pointer to Rn)</code></pre>
<p>These are single-byte instructions, encoded in the SYS/CTL family. When <code>SEP Rn</code> executes,
the <em>next</em> instruction fetch comes from the address in <code>Rn</code> — exactly as on the 1802.
The old <code>R(P)</code> is <em>not</em> modified; it retains the address just past the <code>SEP</code> instruction, ready
for the subroutine to <code>SEP</code> back or <code>RET</code>.</p>

<h3>2.2 MARK, RET, DIS — Designator Save/Restore</h3>
<pre><code>MARK     ;  T ← (XSEL << 4 | PSEL); PUSH T to M(R(SP)); PSEL → XSEL; SP -= 8
           ;  (Mirrors the 1802: saves X|P, makes the caller's P the new X)

RET      ;  POP T from M(R(SP)); SP += 8; T → (XSEL, PSEL); IE ← 1
DIS      ;  POP T from M(R(SP)); SP += 8; T → (XSEL, PSEL); IE ← 0</code></pre>
<p>This directly parallels the 1802's <code>MARK</code> (opcode 0x79), <code>RET</code> (0x70), and <code>DIS</code> (0x71). The
T register is implicit — it exists internally for one cycle to shuttle the designator pair.</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="families">3 Opcode Family Encoding — All 16 Families</h2>

<p>Each family <code>F</code> = 0x0 through 0xF is detailed below with its byte-level encoding.</p>

<!-- ——— F=0: SYS ——— -->
<h3 id="f0">3.0 — Family 0x0: SYS (System &amp; Designator Control)</h3>
<p>Format: <strong>1 byte</strong> — <code>0000 | NNNN</code></p>
<table>
<thead><tr><th>N</th><th>Mnemonic</th><th>Operation</th><th>Notes</th></tr></thead>
<tbody>
<tr><td>0x0</td><td><code>IDL</code></td><td>Enter IDLE; wait for DMA or interrupt</td><td>1802 opcode 0x00</td></tr>
<tr><td>0x1</td><td><code>NOP</code></td><td>No operation; advance PC</td><td></td></tr>
<tr><td>0x2</td><td><code>HALT</code></td><td>Stop processor; requires external reset</td><td></td></tr>
<tr><td>0x3</td><td><code>RESET</code></td><td>Software reset; re-enter boot sequence</td><td></td></tr>
<tr><td>0x4</td><td><code>RTI</code></td><td>Return from interrupt: POP PC, POP FLAGS, restore IE</td><td></td></tr>
<tr><td>0x5</td><td><code>RET</code></td><td>POP (XSEL|PSEL) from stack; SP += 8; IE ← 1</td><td>1802 opcode 0x70</td></tr>
<tr><td>0x6</td><td><code>DIS</code></td><td>POP (XSEL|PSEL) from stack; SP += 8; IE ← 0</td><td>1802 opcode 0x71</td></tr>
<tr><td>0x7</td><td><code>MARK</code></td><td>PUSH (XSEL|PSEL); PSEL → XSEL; SP -= 8</td><td>1802 opcode 0x79</td></tr>
<tr><td>0x8</td><td><code>SAV</code></td><td>Store saved T → M(R(X))</td><td>1802 opcode 0x78</td></tr>
<tr><td>0x9</td><td><code>SEQ</code></td><td>Q ← 1 (set Q output flip-flop)</td><td>1802 opcode 0x7B</td></tr>
<tr><td>0xA</td><td><code>REQ</code></td><td>Q ← 0 (reset Q output)</td><td>1802 opcode 0x7A</td></tr>
<tr><td>0xB</td><td><code>EI</code></td><td>IE ← 1 (enable maskable interrupts)</td><td></td></tr>
<tr><td>0xC</td><td><code>DI</code></td><td>IE ← 0 (disable maskable interrupts)</td><td></td></tr>
<tr><td>0xD</td><td><code>CALL.L</code></td><td><em>See Section 4 — hardware CALL</em></td><td>2-byte: takes Rn target (convenience)</td></tr>
<tr><td>0xE</td><td><code>RET.L</code></td><td><em>See Section 4 — hardware RET</em></td><td>Pops link address from stack</td></tr>
<tr><td>0xF</td><td><em>TRAP</em></td><td>Software trap (reserved/illegal opcode vector)</td><td></td></tr>
</tbody>
</table>

<!-- ——— F=1: REG ——— -->
<h3 id="f1">3.1 — Family 0x1: REG (Register Ops — 1802 legacy)</h3>
<p>Format: <strong>1 byte</strong> — <code>0001 | NNNN</code></p>
<p>These mirror the 1802's single-byte register operations where <code>N</code> selects <code>R(N)</code>:</p>
<table>
<thead><tr><th>Byte 0</th><th>Mnemonic</th><th>Operation</th><th>1802 equiv</th></tr></thead>
<tbody>
<tr><td><code>1N</code></td><td><code>INC Rn</code></td><td>R(N) ← R(N) + 1</td><td>1802: <code>1N</code></td></tr>
</tbody>
</table>

<h3 id="f2">3.2 — Family 0x2: REG2 (Register Ops — 1802 legacy, continued)</h3>
<p>Format: <strong>1 byte</strong> — <code>0010 | NNNN</code></p>
<table>
<thead><tr><th>Byte 0</th><th>Mnemonic</th><th>Operation</th><th>1802 equiv</th></tr></thead>
<tbody>
<tr><td><code>2N</code></td><td><code>DEC Rn</code></td><td>R(N) ← R(N) - 1</td><td>1802: <code>2N</code></td></tr>
</tbody>
</table>

<!-- ——— F=3: BR (short branch) ——— -->
<h3 id="f3">3.3 — Family 0x3: BR (Short Branch / Short Skip)</h3>
<p>Format: <strong>2 bytes</strong> — <code>0011 | CCCC</code> <code>OOOOOOOO</code></p>
<div class="bit-diagram">
  Byte 0:  0011 | CCCC       (C = condition code, 4 bits)
  Byte 1:  OOOO OOOO         (signed 8-bit PC-relative offset)
</div>

<p>The offset is sign-extended and added to the address of the byte <em>following</em> byte 1 (i.e.,
the address of the next instruction). Range: −128 to +127 bytes from the next instruction.</p>

<p>When <code>C = 0000</code> (AL, always), this is an unconditional short branch — the 1802's <code>BR</code> (0x30).</p>
<p>When <code>C = 1111</code> (NV, never), byte 1 is skipped — the 1802's <code>NBR</code>/<code>SKP</code> (0x38).</p>

<p><strong>Condition codes</strong> (shared with long branch and SKIP):</p>
<table>
<thead><tr><th>CCCC</th><th>Mnemonic</th><th>Condition</th><th>1802 parallel</th></tr></thead>
<tbody>
<tr><td>0000</td><td>AL</td><td>Always</td><td>BR (0x30)</td></tr>
<tr><td>0001</td><td>EQ / BZ</td><td>Z = 1</td><td>BZ (0x32)</td></tr>
<tr><td>0010</td><td>NE / BNZ</td><td>Z = 0</td><td>BNZ (0x3A)</td></tr>
<tr><td>0011</td><td>CS / BDF</td><td>C = 1 (carry / DF=1)</td><td>BDF (0x33)</td></tr>
<tr><td>0100</td><td>CC / BNF</td><td>C = 0 (no carry / DF=0)</td><td>BNF (0x3B)</td></tr>
<tr><td>0101</td><td>MI</td><td>N = 1 (negative)</td><td>—</td></tr>
<tr><td>0110</td><td>PL</td><td>N = 0 (positive or zero)</td><td>—</td></tr>
<tr><td>0111</td><td>VS</td><td>V = 1 (signed overflow)</td><td>—</td></tr>
<tr><td>1000</td><td>VC</td><td>V = 0</td><td>—</td></tr>
<tr><td>1001</td><td>GT</td><td>G = 1 (unsigned greater)</td><td>—</td></tr>
<tr><td>1010</td><td>LE</td><td>G = 0</td><td>—</td></tr>
<tr><td>1011</td><td>BQ</td><td>Q = 1 (Q flip-flop set)</td><td>BQ (0x31)</td></tr>
<tr><td>1100</td><td>BNQ</td><td>Q = 0</td><td>BNQ (0x39)</td></tr>
<tr><td>1101</td><td>SAT</td><td>S = 1 (saturation sticky)</td><td>—</td></tr>
<tr><td>1110</td><td>EF</td><td>Any EF flag set (external flag input)</td><td>B1-B4 (0x34-0x37)</td></tr>
<tr><td>1111</td><td>NV / SKP</td><td>Never (= skip next 1 byte)</td><td>NBR/SKP (0x38)</td></tr>
</tbody>
</table>

<aside class="note">
<strong>1802 compatibility note:</strong> The 1802 tested individual EF lines (EF1–EF4) via dedicated branch opcodes
(B1–BN4). Megapad-64 consolidates these to a single <code>EF</code> condition in the branch encoding, with the
specific EF line readable via <code>CSRR</code> or testable via a mask in R(X). Four dedicated
branch opcodes for four flag pins is elegant on the 1802 but doesn't scale; the Megapad-64 trades
four condition slots for richer flag-based conditions (MI/PL, VS/VC, GT/LE, SAT) that the 1802 lacked.
</aside>

<!-- ——— F=4: LBR (long branch) ——— -->
<h3 id="f4">3.4 — Family 0x4: LBR (Long Branch / Long Skip)</h3>
<p>Format: <strong>3 bytes</strong> — <code>0100 | CCCC</code> <code>offset_hi</code> <code>offset_lo</code></p>
<div class="bit-diagram">
  Byte 0:  0100 | CCCC       (same condition codes as short branch)
  Byte 1:  high byte of signed 16-bit PC-relative offset
  Byte 2:  low byte   (little-endian: byte 1 = high, byte 2 = low → matches 1802 convention)
</div>
<p>Range: −32768 to +32767 bytes from the next instruction. The 1802's long branch (0xCN) used
a 16-bit <em>absolute</em> address; Megapad-64 uses PC-relative for position-independent code, but the
3-byte shape and condition-in-the-first-byte structure are preserved.</p>

<p>When <code>C = 1111</code> (NV), this is a <strong>long skip</strong> — the 1802's <code>LSKP</code> (0xC8). PC advances by 3, skipping 2 bytes.</p>

<!-- ——— F=5: MEM (scalar load/store) ——— -->
<h3 id="f5">3.5 — Family 0x5: MEM (Scalar Memory Load / Store)</h3>
<p>Format: <strong>2 bytes</strong> — <code>0101 | SSSS</code> <code>Rd|Rs</code></p>

<div class="bit-diagram">
  Byte 0:  0101 | SSSS       (S = sub-operation)
  Byte 1:  RRRR | RRRR       (Rd/target in high nibble, Rs/source in low nibble)
</div>

<p>These provide the general-purpose scalar memory access the 1802 performed via <code>LDN</code>,
<code>LDA</code>, <code>STR</code>, <code>LDX</code>, <code>LDXA</code>, and <code>STXD</code>. The width of the access is determined by a 2-bit field
within <code>SSSS</code>.</p>

<table>
<thead><tr><th>SSSS</th><th>Mnemonic</th><th>Operation</th><th>Width</th><th>1802 parallel</th></tr></thead>
<tbody>
<tr><td>0000</td><td><code>LDN Rd, Rn</code></td><td>Rd ← M(R(N)); <em>N ≠ 0</em></td><td>64-bit</td><td>LDN 0N</td></tr>
<tr><td>0001</td><td><code>LDA Rd, Rn</code></td><td>Rd ← M(R(N)); R(N) += 8</td><td>64-bit</td><td>LDA 4N</td></tr>
<tr><td>0010</td><td><code>LDX Rd</code></td><td>Rd ← M(R(X))</td><td>64-bit</td><td>LDX F0</td></tr>
<tr><td>0011</td><td><code>LDXA Rd</code></td><td>Rd ← M(R(X)); R(X) += 8</td><td>64-bit</td><td>LDXA 72</td></tr>
<tr><td>0100</td><td><code>STR Rn, Rs</code></td><td>M(R(N)) ← Rs</td><td>64-bit</td><td>STR 5N</td></tr>
<tr><td>0101</td><td><code>STXD Rs</code></td><td>M(R(X)) ← Rs; R(X) -= 8</td><td>64-bit</td><td>STXD 73</td></tr>
<tr><td>0110</td><td><code>LD.B Rd, Rn</code></td><td>Rd ← zeroext(M8(R(N)))</td><td>8-bit</td><td>(1802 is 8-bit native)</td></tr>
<tr><td>0111</td><td><code>ST.B Rn, Rs</code></td><td>M8(R(N)) ← Rs[7:0]</td><td>8-bit</td><td></td></tr>
<tr><td>1000</td><td><code>LD.H Rd, Rn</code></td><td>Rd ← zeroext(M16(R(N)))</td><td>16-bit</td><td></td></tr>
<tr><td>1001</td><td><code>ST.H Rn, Rs</code></td><td>M16(R(N)) ← Rs[15:0]</td><td>16-bit</td><td></td></tr>
<tr><td>1010</td><td><code>LD.W Rd, Rn</code></td><td>Rd ← zeroext(M32(R(N)))</td><td>32-bit</td><td></td></tr>
<tr><td>1011</td><td><code>ST.W Rn, Rs</code></td><td>M32(R(N)) ← Rs[31:0]</td><td>32-bit</td><td></td></tr>
<tr><td>1100</td><td><code>LD.SB Rd, Rn</code></td><td>Rd ← signext(M8(R(N)))</td><td>8→64 sign-ext</td><td></td></tr>
<tr><td>1101</td><td><code>LD.SH Rd, Rn</code></td><td>Rd ← signext(M16(R(N)))</td><td>16→64 sign-ext</td><td></td></tr>
<tr><td>1110</td><td><code>LD.SW Rd, Rn</code></td><td>Rd ← signext(M32(R(N)))</td><td>32→64 sign-ext</td><td></td></tr>
<tr><td>1111</td><td><code>LD.D Rd, [Rn+off]</code></td><td><em>See offset load (3-byte form)</em></td><td>64-bit + off</td><td></td></tr>
</tbody>
</table>

<aside class="note">
<strong>Addressing modes — 1802 heritage:</strong> The 1802 always accesses memory through a register pointer
(<code>R(N)</code> or <code>R(X)</code>). Megapad-64 does the same: there is no <code>[Rd + Rs]</code> indexed mode and
no absolute-address mode in the primary encoding. To load from an absolute address, load the
address into a register first (<code>LDI</code>/<code>LHI</code> or <code>EXT LDI</code>), then use <code>LDN</code>. This is exactly
how the 1802 works.
<br><br>
The one addition is <code>LD.D Rd, [Rn+off8]</code> (SSSS=1111), which appends a signed 8-bit offset byte
(byte 2), making it a 3-byte instruction. This supports stack-frame access patterns modern
compilers need, without breaking the register-indirect philosophy.
</aside>

<h4>3.5.1 Offset Load/Store (SSSS = 1111)</h4>
<p>Format: <strong>3 bytes</strong></p>
<div class="bit-diagram">
  Byte 0:  0101 | 1111
  Byte 1:  Rd(3:0) | Rn(3:0)
  Byte 2:  signed 8-bit offset (−128 to +127, scaled by access width)
</div>
<p>Effective address = <code>R(N) + sign_extend(offset) × 8</code>. This gives ±1 KiB reach for 64-bit
stack slots — sufficient for most function frames.</p>
<p>Additional offset widths (16/32-bit) can use the <code>EXT</code> prefix for byte 2 = 16-bit offset
field.</p>

<!-- ——— F=6: IMM ——— -->
<h3 id="f6">3.6 — Family 0x6: IMM (Immediate Operations)</h3>
<p>Format: <strong>2 or 3 bytes</strong> — <code>0110 | SSSS</code> <code>Rn|imm…</code></p>

<div class="bit-diagram">
  Byte 0:  0110 | SSSS        (S = sub-operation)
  Byte 1:  imm8  (for 1-reg ops) or Rn(7:4)|imm4 (for register + tiny immediate)
  Byte 2:  (optional, for 16-bit immediate forms)
</div>

<table>
<thead><tr><th>SSSS</th><th>Mnemonic</th><th>Bytes</th><th>Operation</th><th>1802 parallel</th></tr></thead>
<tbody>
<tr><td>0000</td><td><code>LDI Rn, imm8</code></td><td>3</td><td>R(N) ← zeroext(imm8); byte1=Rn|0, byte2=imm8</td><td>LDI (0xF8)</td></tr>
<tr><td>0001</td><td><code>LHI Rn, imm16</code></td><td>4</td><td>R(N)[63:48] ← imm16; lower 48 bits unchanged</td><td>—</td></tr>
<tr><td>0010</td><td><code>ADDI Rn, imm8</code></td><td>3</td><td>R(N) ← R(N) + signext(imm8); update FLAGS</td><td>ADI (0xFC)</td></tr>
<tr><td>0011</td><td><code>ANDI Rn, imm8</code></td><td>3</td><td>R(N) ← R(N) AND zeroext(imm8); update Z/N/P</td><td>ANI (0xFA)</td></tr>
<tr><td>0100</td><td><code>ORI Rn, imm8</code></td><td>3</td><td>R(N) ← R(N) OR zeroext(imm8); update Z/N/P</td><td>ORI (0xF9)</td></tr>
<tr><td>0101</td><td><code>XORI Rn, imm8</code></td><td>3</td><td>R(N) ← R(N) XOR zeroext(imm8); update Z/N/P</td><td>XRI (0xFB)</td></tr>
<tr><td>0110</td><td><code>CMPI Rn, imm8</code></td><td>3</td><td>temp ← R(N) − signext(imm8); update Z/C/N/V/G</td><td>—</td></tr>
<tr><td>0111</td><td><code>SUBI Rn, imm8</code></td><td>3</td><td>R(N) ← R(N) − signext(imm8); update FLAGS</td><td>SDI/SMI (0xFD/0xFF)</td></tr>
<tr><td>1000</td><td><code>LSLI Rn, imm4</code></td><td>2</td><td>R(N) ← R(N) << imm4 (byte1 = Rn|imm4)</td><td>—</td></tr>
<tr><td>1001</td><td><code>LSRI Rn, imm4</code></td><td>2</td><td>R(N) ← R(N) >> imm4 (logical)</td><td>—</td></tr>
<tr><td>1010</td><td><code>ASRI Rn, imm4</code></td><td>2</td><td>R(N) ← R(N) >>> imm4 (arithmetic)</td><td>—</td></tr>
<tr><td>1011</td><td><code>ROLI Rn, imm4</code></td><td>2</td><td>R(N) ← rotate_left(R(N), imm4)</td><td>—</td></tr>
<tr><td>1100</td><td><code>GLO Rn</code></td><td>2</td><td>D ← R(N)[7:0] (get low byte — 1802 style)</td><td>GLO (0x8N)</td></tr>
<tr><td>1101</td><td><code>GHI Rn</code></td><td>2</td><td>D ← R(N)[15:8] (get high byte — 1802 style)</td><td>GHI (0x9N)</td></tr>
<tr><td>1110</td><td><code>PLO Rn</code></td><td>2</td><td>R(N)[7:0] ← D (put low byte)</td><td>PLO (0xAN)</td></tr>
<tr><td>1111</td><td><code>PHI Rn</code></td><td>2</td><td>R(N)[15:8] ← D (put high byte)</td><td>PHI (0xBN)</td></tr>
</tbody>
</table>

<aside class="note">
<strong>GLO/GHI/PLO/PHI:</strong> These are direct 1802 instruction mirrors that use the implicit <code>D</code>
accumulator register. On the 1802, <code>D</code> is the only way to move data between registers and memory.
Megapad-64 preserves this path as a "legacy mode" for 1802-style programming. The <code>D</code> register on
Megapad-64 is the low 8 bits of <code>R0</code> (by convention), or a dedicated 8-bit latch visible via CSR.
<br><br>
For modern 64-bit code, use the register-to-register <code>MOV</code>, <code>ADD</code>, etc. in the ALU family instead.
</aside>

<!-- ——— F=7: ALU ——— -->
<h3 id="f7">3.7 — Family 0x7: ALU (Register-to-Register Scalar ALU)</h3>
<p>Format: <strong>2 bytes</strong> — <code>0111 | SSSS</code> <code>Rd | Rs</code></p>

<div class="bit-diagram">
  Byte 0:  0111 | SSSS       (S = ALU sub-operation)
  Byte 1:  Rd(3:0) | Rs(3:0)  (destination in high nibble, source in low nibble)
</div>

<table>
<thead><tr><th>SSSS</th><th>Mnemonic</th><th>Operation</th><th>FLAGS updated</th></tr></thead>
<tbody>
<tr><td>0000</td><td><code>ADD Rd, Rs</code></td><td>Rd ← Rd + Rs</td><td>Z C N V P</td></tr>
<tr><td>0001</td><td><code>ADC Rd, Rs</code></td><td>Rd ← Rd + Rs + C</td><td>Z C N V P</td></tr>
<tr><td>0010</td><td><code>SUB Rd, Rs</code></td><td>Rd ← Rd − Rs</td><td>Z C N V P</td></tr>
<tr><td>0011</td><td><code>SBB Rd, Rs</code></td><td>Rd ← Rd − Rs − !C</td><td>Z C N V P</td></tr>
<tr><td>0100</td><td><code>AND Rd, Rs</code></td><td>Rd ← Rd AND Rs</td><td>Z N P; C←0, V←0</td></tr>
<tr><td>0101</td><td><code>OR Rd, Rs</code></td><td>Rd ← Rd OR Rs</td><td>Z N P; C←0, V←0</td></tr>
<tr><td>0110</td><td><code>XOR Rd, Rs</code></td><td>Rd ← Rd XOR Rs</td><td>Z N P; C←0, V←0</td></tr>
<tr><td>0111</td><td><code>CMP Rd, Rs</code></td><td>temp ← Rd − Rs (flags only)</td><td>Z C N V G</td></tr>
<tr><td>1000</td><td><code>MOV Rd, Rs</code></td><td>Rd ← Rs</td><td>— (no flag change)</td></tr>
<tr><td>1001</td><td><code>NOT Rd, Rs</code></td><td>Rd ← ~Rs</td><td>Z N P</td></tr>
<tr><td>1010</td><td><code>NEG Rd, Rs</code></td><td>Rd ← 0 − Rs</td><td>Z C N V P</td></tr>
<tr><td>1011</td><td><code>SHL Rd, Rs</code></td><td>Rd ← Rd << Rs[5:0]</td><td>Z C N P (C = last bit shifted out)</td></tr>
<tr><td>1100</td><td><code>SHR Rd, Rs</code></td><td>Rd ← Rd >> Rs[5:0] (logical)</td><td>Z C N P</td></tr>
<tr><td>1101</td><td><code>SAR Rd, Rs</code></td><td>Rd ← Rd >>> Rs[5:0] (arithmetic)</td><td>Z C N P</td></tr>
<tr><td>1110</td><td><code>ROL Rd, Rs</code></td><td>Rd ← rotate_left(Rd, Rs[5:0])</td><td>Z N P</td></tr>
<tr><td>1111</td><td><code>ROR Rd, Rs</code></td><td>Rd ← rotate_right(Rd, Rs[5:0])</td><td>Z N P</td></tr>
</tbody>
</table>

<aside class="tip">
<strong>1802 mapping:</strong> The 1802's ALU always operated as <code>M(R(X)) op D → D</code>. On Megapad-64,
the <code>R(X)</code>-indirect ALU path is available via the MEM-ALU family (0x8) below. This family (0x7) is the
modern register-to-register path.
</aside>

<!-- ——— F=8: MEMALU ——— -->
<h3 id="f8">3.8 — Family 0x8: MEMALU (Memory-ALU via R(X) — 1802 compatibility)</h3>
<p>Format: <strong>1 byte</strong> — <code>1000 | SSSS</code></p>

<p>These mirror the 1802's ALU instructions exactly: the operand comes from <code>M(R(X))</code>, operates
with the <code>D</code> register (or Rd register for Megapad extended mode), and writes back to <code>D</code>.</p>

<table>
<thead><tr><th>SSSS</th><th>Mnemonic</th><th>Operation</th><th>1802 opcode</th></tr></thead>
<tbody>
<tr><td>0000</td><td><code>LDX</code></td><td>D ← M(R(X))</td><td>F0</td></tr>
<tr><td>0001</td><td><code>OR.X</code></td><td>D ← M(R(X)) OR D</td><td>F1</td></tr>
<tr><td>0010</td><td><code>AND.X</code></td><td>D ← M(R(X)) AND D</td><td>F2</td></tr>
<tr><td>0011</td><td><code>XOR.X</code></td><td>D ← M(R(X)) XOR D</td><td>F3</td></tr>
<tr><td>0100</td><td><code>ADD.X</code></td><td>D ← M(R(X)) + D; carry → C</td><td>F4</td></tr>
<tr><td>0101</td><td><code>SD.X</code></td><td>D ← M(R(X)) − D; borrow → C</td><td>F5</td></tr>
<tr><td>0110</td><td><code>SHR.D</code></td><td>Shift D right; LSB→C, 0→MSB</td><td>F6</td></tr>
<tr><td>0111</td><td><code>SM.X</code></td><td>D ← D − M(R(X)); borrow → C</td><td>F7</td></tr>
<tr><td>1000</td><td><code>ADC.X</code></td><td>D ← M(R(X)) + D + C</td><td>74</td></tr>
<tr><td>1001</td><td><code>SDB.X</code></td><td>D ← M(R(X)) − D − !C</td><td>75</td></tr>
<tr><td>1010</td><td><code>SHRC.D</code></td><td>Shift D right through carry</td><td>76</td></tr>
<tr><td>1011</td><td><code>SMB.X</code></td><td>D ← D − M(R(X)) − !C</td><td>77</td></tr>
<tr><td>1100</td><td><code>SHL.D</code></td><td>Shift D left; MSB→C, 0→LSB</td><td>FE</td></tr>
<tr><td>1101</td><td><code>SHLC.D</code></td><td>Shift D left through carry</td><td>7E</td></tr>
<tr><td>1110</td><td><code>IRX</code></td><td>R(X) ← R(X) + 1</td><td>60</td></tr>
<tr><td>1111</td><td><code>LDXA</code></td><td>D ← M(R(X)); R(X) += 1</td><td>72</td></tr>
</tbody>
</table>

<aside class="note">
<strong>D register on Megapad-64:</strong> For 1802 compatibility, <code>D</code> is an architecturally visible 8-bit
register (CSR-accessible). In 1802-mode operations (this family), <code>D</code> acts exactly as on the 1802:
8-bit accumulator, <code>DF</code> ≡ <code>FLAGS.C</code>. For 64-bit code, use the full-width ALU family (0x7) instead.
</aside>

<!-- ——— F=9: I/O ——— -->
<h3 id="f9">3.9 — Family 0x9: I/O (Port I/O)</h3>
<p>Format: <strong>1 byte</strong> — <code>1001 | NNNN</code></p>

<table>
<thead><tr><th>N</th><th>Mnemonic</th><th>Operation</th><th>1802 parallel</th></tr></thead>
<tbody>
<tr><td>0x0</td><td><em>reserved</em></td><td>—</td><td>—</td></tr>
<tr><td>0x1–0x7</td><td><code>OUT N</code></td><td>M(R(X)) → PORT[N]; R(X) += 1</td><td>OUT 1–7 (0x61–0x67)</td></tr>
<tr><td>0x8</td><td><em>reserved</em></td><td>—</td><td>—</td></tr>
<tr><td>0x9–0xF</td><td><code>INP N-8</code></td><td>PORT[N-8] → M(R(X)); PORT → D</td><td>INP 1–7 (0x69–0x6F)</td></tr>
</tbody>
</table>

<p>This is a byte-for-byte mirror of the 1802's I/O encoding structure (the 1802's 0x6N family),
relocated to Megapad-64's 0x9 family. The port numbers 1–7 and the direction convention (low = out,
high = in) are preserved.</p>

<!-- ——— F=A: SEP/SEX/CTL ——— -->
<h3 id="fA">3.A — Family 0xA: CTL (Designator &amp; Cursor Control)</h3>
<p>Format: <strong>1 byte</strong> — <code>1010 | NNNN</code></p>
<table>
<thead><tr><th>N</th><th>Mnemonic</th><th>Operation</th><th>1802 parallel</th></tr></thead>
<tbody>
<tr><td>0x0</td><td><code>SEP R0</code></td><td>PSEL ← 0 (switch PC to R0)</td><td>SEP 0 (0xD0)</td></tr>
<tr><td>…</td><td><code>SEP Rn</code></td><td>PSEL ← N</td><td></td></tr>
<tr><td>0xF</td><td><code>SEP R15</code></td><td>PSEL ← 15</td><td>SEP F (0xDF)</td></tr>
</tbody>
</table>
<p><strong>SEP</strong> occupies a full family (all 16 N values), exactly as on the 1802 (0xDN). This is the
1802's subroutine call mechanism and is treated as a first-class instruction.</p>

<h3 id="fB">3.B — Family 0xB: SEX (Set X Designator)</h3>
<p>Format: <strong>1 byte</strong> — <code>1011 | NNNN</code></p>
<table>
<thead><tr><th>N</th><th>Mnemonic</th><th>Operation</th><th>1802 parallel</th></tr></thead>
<tbody>
<tr><td>0x0–0xF</td><td><code>SEX Rn</code></td><td>XSEL ← N (switch data pointer to Rn)</td><td>SEX N (0xEN)</td></tr>
</tbody>
</table>
<p>Also a full family, exactly as the 1802's 0xEN. This is the dual of <code>SEP</code> for the data pointer.</p>

<!-- ——— F=C: MUL/DIV ——— -->
<h3 id="fC">3.C — Family 0xC: MUL/DIV (Multiply &amp; Divide)</h3>
<p>Format: <strong>2 bytes</strong> — <code>1100 | SSSS</code> <code>Rd | Rs</code></p>

<table>
<thead><tr><th>SSSS</th><th>Mnemonic</th><th>Operation</th><th>Cycles</th></tr></thead>
<tbody>
<tr><td>0000</td><td><code>MUL Rd, Rs</code></td><td>Rd ← low64(Rd × Rs) (signed)</td><td>micro-coded</td></tr>
<tr><td>0001</td><td><code>MULH Rd, Rs</code></td><td>Rd ← high64(Rd × Rs) (signed)</td><td>micro-coded</td></tr>
<tr><td>0010</td><td><code>UMUL Rd, Rs</code></td><td>Rd ← low64(Rd × Rs) (unsigned)</td><td>micro-coded</td></tr>
<tr><td>0011</td><td><code>UMULH Rd, Rs</code></td><td>Rd ← high64(Rd × Rs) (unsigned)</td><td>micro-coded</td></tr>
<tr><td>0100</td><td><code>DIV Rd, Rs</code></td><td>Rd ← Rd / Rs (signed); R0 ← Rd % Rs</td><td>micro-coded</td></tr>
<tr><td>0101</td><td><code>UDIV Rd, Rs</code></td><td>Rd ← Rd / Rs (unsigned); R0 ← Rd % Rs</td><td>micro-coded</td></tr>
<tr><td>0110</td><td><code>MOD Rd, Rs</code></td><td>Rd ← Rd % Rs (signed)</td><td>micro-coded</td></tr>
<tr><td>0111</td><td><code>UMOD Rd, Rs</code></td><td>Rd ← Rd % Rs (unsigned)</td><td>micro-coded</td></tr>
<tr><td>1000–1111</td><td><em>reserved</em></td><td>—</td><td></td></tr>
</tbody>
</table>

<aside class="note">
<strong>Remainder placement:</strong> <code>DIV</code>/<code>UDIV</code> place the quotient in Rd and the remainder in R0.
If Rd <em>is</em> R0, the remainder is lost (quotient overwrites). This avoids needing a second destination
register field and keeps the encoding 2 bytes.
<br><br>
<strong>Divide-by-zero:</strong> Raises a trap (see SPECS Section 7.2). Rd is not modified.
</aside>

<!-- ——— F=D: CSR ——— -->
<h3 id="fD">3.D — Family 0xD: CSR (Control/Status Register Access)</h3>
<p>Format: <strong>2 bytes</strong> — <code>1101 | W</code> <code>csr_addr(4)|Rn(4)</code></p>

<div class="bit-diagram">
  Byte 0:  1101 | 0 R R R      CSRR: Rd ← CSR[addr]  (W=0, Rd in N[2:0], combined with byte1)
  Byte 0:  1101 | 1 R R R      CSRW: CSR[addr] ← Rs  (W=1, Rs in N[2:0], combined with byte1)
  Byte 1:  CSR address (8 bits)
</div>

<p>Bit 3 of <code>N</code> selects read (0) or write (1). Bits 2:0 of <code>N</code> provide the low 3 bits of the register
selector; byte 1 provides the 8-bit CSR address.</p>

<h4>3.D.1 CSR Address Map</h4>
<table>
<thead><tr><th>CSR Addr</th><th>Name</th><th>Bits</th><th>Description</th></tr></thead>
<tbody>
<tr><td>0x00</td><td><code>FLAGS</code></td><td>8</td><td>Z C N V P G I S</td></tr>
<tr><td>0x01</td><td><code>PSEL</code></td><td>4</td><td>PC designator (which GPR is PC)</td></tr>
<tr><td>0x02</td><td><code>XSEL</code></td><td>4</td><td>Data pointer designator (which GPR is R(X))</td></tr>
<tr><td>0x03</td><td><code>SPSEL</code></td><td>4</td><td>Stack pointer designator</td></tr>
<tr><td>0x04</td><td><code>D</code></td><td>8</td><td>Legacy D accumulator (1802 compat)</td></tr>
<tr><td>0x05</td><td><code>DF</code></td><td>1</td><td>Legacy data flag (alias for FLAGS.C)</td></tr>
<tr><td>0x06</td><td><code>Q</code></td><td>1</td><td>Q output flip-flop</td></tr>
<tr><td>0x07</td><td><code>T</code></td><td>8</td><td>Saved XSEL|PSEL (1802 T register)</td></tr>
<tr><td>0x08</td><td><code>IE</code></td><td>1</td><td>Interrupt enable (alias for FLAGS.I)</td></tr>
<tr><td>0x10</td><td><code>SB</code></td><td>4</td><td>Megapad bank selector</td></tr>
<tr><td>0x11</td><td><code>SR</code></td><td>20</td><td>Tile cursor row</td></tr>
<tr><td>0x12</td><td><code>SC</code></td><td>20</td><td>Tile cursor column</td></tr>
<tr><td>0x13</td><td><code>SW</code></td><td>20</td><td>Tile cursor stride width</td></tr>
<tr><td>0x14</td><td><code>TMODE</code></td><td>8</td><td>MEX element width and sign</td></tr>
<tr><td>0x15</td><td><code>TCTRL</code></td><td>8</td><td>MEX accumulate/zero/saturation control</td></tr>
<tr><td>0x16</td><td><code>TSRC0</code></td><td>64</td><td>Tile source 0 base address</td></tr>
<tr><td>0x17</td><td><code>TSRC1</code></td><td>64</td><td>Tile source 1 base address</td></tr>
<tr><td>0x18</td><td><code>TDST</code></td><td>64</td><td>Tile destination base address</td></tr>
<tr><td>0x19</td><td><code>ACC0</code></td><td>64</td><td>Accumulator bank 0 (per SB)</td></tr>
<tr><td>0x1A</td><td><code>ACC1</code></td><td>64</td><td>Accumulator bank 1</td></tr>
<tr><td>0x1B</td><td><code>ACC2</code></td><td>64</td><td>Accumulator bank 2</td></tr>
<tr><td>0x1C</td><td><code>ACC3</code></td><td>64</td><td>Accumulator bank 3</td></tr>
<tr><td>0x20</td><td><code>IVT_BASE</code></td><td>64</td><td>Interrupt vector table base address</td></tr>
<tr><td>0x21</td><td><code>IVEC_ID</code></td><td>8</td><td>Current interrupt/trap vector index</td></tr>
<tr><td>0x22</td><td><code>TRAP_ADDR</code></td><td>64</td><td>Faulting address for bus/alignment faults</td></tr>
<tr><td>0x30</td><td><code>MEGAPAD_SIZE</code></td><td>4</td><td>Read-only: Megapad size config (0=8M, 1=16M, 2=32M, 3=64M)</td></tr>
<tr><td>0x31</td><td><code>CPUID</code></td><td>64</td><td>Read-only: Implementation ID / revision</td></tr>
</tbody>
</table>

<!-- ——— F=E: MEX ——— -->
<h3 id="fE">3.E — Family 0xE: MEX (Tile-ALU)</h3>
<p>Format: <strong>1–3 bytes</strong> — <code>1110 | SS Op</code> [funct] [operand]</p>

<div class="bit-diagram">
  Byte 0:  1110 | SS | OO
             SS  = operand selector (2 bits, see SPECS §5)
             OO  = major op: 00=TALU, 01=TMUL, 10=TRED, 11=TSYS

  Byte 1:  (when needed) sub-function code
             TALU: 3-bit funct (ADD/SUB/AND/OR/XOR/MIN/MAX/ABS) + 5 reserved
             TMUL: 2-bit funct (MUL/DOT/res/res) + 6 reserved
             TRED: 3-bit funct (SUM/MIN/MAX/POPCNT/L1/res/res/res) + 5 reserved
             TSYS: 3-bit funct (TRANS/CONV3/MOVBANK/LOADC/ZERO/res/res/res)

  Byte 2:  (when SS=01) register index Rn for broadcast operand
</div>

<p>This encoding is unchanged from SPECS §5 and is self-consistent. The primary byte packs the
operand selector and major op into the N nibble (2+2 bits), and the sub-function in byte 1 provides
the specific operation. Total instruction length:</p>
<ul>
  <li><strong>SS=00, 10, 11:</strong> 2 bytes (byte 0 + funct byte 1)</li>
  <li><strong>SS=01:</strong> 3 bytes (byte 0 + funct + register selector byte 2)</li>
  <li><strong>TSYS TRANS, ZERO:</strong> funct byte can be omitted if these are frequent — or kept for uniformity</li>
</ul>

<!-- ——— F=F: EXT ——— -->
<h3 id="fF">3.F — Family 0xF: EXT (Extension Prefix)</h3>
<p>Format: <strong>1 byte prefix</strong> — <code>1111 | MMMM</code>, followed by the modified instruction</p>

<div class="bit-diagram">
  Byte 0:  1111 | MMMM       (M = modifier code)
  Byte 1+: the instruction being modified (fetched and decoded normally)
</div>

<p>The <code>EXT</code> byte modifies the <em>next</em> instruction. This parallels how the 1802 uses inline data
bytes following the opcode — it's a natural extension of the "PC auto-advances past inline data"
principle.</p>

<table>
<thead><tr><th>MMMM</th><th>Name</th><th>Effect on next instruction</th></tr></thead>
<tbody>
<tr><td>0000</td><td><code>EXT.IMM64</code></td><td>Next immediate instruction uses a 64-bit inline immediate (8 bytes follow
    the target instruction's normal encoding, replacing the shorter immediate).</td></tr>
<tr><td>0001</td><td><code>EXT.OFF16</code></td><td>Next memory instruction's offset field is 16-bit signed (replaces 8-bit).</td></tr>
<tr><td>0010</td><td><code>EXT.OFF32</code></td><td>Next memory instruction's offset field is 32-bit signed.</td></tr>
<tr><td>0011</td><td><code>EXT.ABS</code></td><td>Next branch uses an absolute 64-bit target address (8 bytes inline).</td></tr>
<tr><td>0100</td><td><code>EXT.SIMD</code></td><td>Next ALU instruction operates as packed SIMD (see SPECS §4, family 0x8).
    Lane width from TMODE.E.</td></tr>
<tr><td>0101</td><td><code>EXT.ATOM</code></td><td>Next memory load/store is atomic: LL (load-linked) for loads,
    SC (store-conditional) for stores. FLAGS.Z ← SC success.</td></tr>
<tr><td>0110</td><td><code>EXT.CAS</code></td><td>Next instruction is CAS: compare-and-swap.
    <code>if M(Rn) == Rd then M(Rn) ← Rs; Z←1 else Rd ← M(Rn); Z←0</code></td></tr>
<tr><td>0111–1110</td><td><em>reserved</em></td><td>Future expansion (FPU modes, wider SIMD, etc.)</td></tr>
<tr><td>1111</td><td><code>EXT.EXT</code></td><td>Double prefix: the <em>next</em> EXT byte provides a second modifier. Reserved for
    future use; traps in v1.0.</td></tr>
</tbody>
</table>

<aside class="tip">
<strong>Example — loading a full 64-bit immediate:</strong>
<pre><code>F0          ; EXT.IMM64 prefix
60 30       ; LDI R3 (family 0x6, sub 0, Rn=3)
78 56 34 12 ; imm64 low bytes (little-endian)
F0 DE BC 9A ; imm64 high bytes
; → R3 = 0x9ABCDEF012345678</code></pre>
</aside>

<!-- ——— F=remaining: tile load/store, CTL ——— -->
<h3>3.— Families Not Yet Assigned to a Nibble</h3>

<aside class="warn">
<strong>Design note:</strong> The current mapping uses families 0x0–0xF as follows. Two families from the
original SPECS (LD1D/ST1D = 0x5, LD2D/ST2D = 0x6) have been remapped to accommodate the new
scalar MEM family. The tile load/store and cursor-control operations are consolidated:
</aside>

<table>
<thead><tr><th>Family (F)</th><th>Assignment</th><th>Bytes</th></tr></thead>
<tbody>
<tr><td>0x0</td><td>SYS (system, designator save/restore, IDL/NOP/HALT)</td><td>1</td></tr>
<tr><td>0x1</td><td>INC Rn (1802: 0x1N)</td><td>1</td></tr>
<tr><td>0x2</td><td>DEC Rn (1802: 0x2N)</td><td>1</td></tr>
<tr><td>0x3</td><td>BR — short branch/skip (1802: 0x3N)</td><td>2</td></tr>
<tr><td>0x4</td><td>LBR — long branch/skip (1802: 0xCN)</td><td>3</td></tr>
<tr><td>0x5</td><td>MEM — scalar load/store</td><td>2–3</td></tr>
<tr><td>0x6</td><td>IMM — immediate operations</td><td>2–4</td></tr>
<tr><td>0x7</td><td>ALU — register-to-register scalar</td><td>2</td></tr>
<tr><td>0x8</td><td>MEMALU — R(X)-indirect ALU (1802 compat)</td><td>1</td></tr>
<tr><td>0x9</td><td>I/O — port IN/OUT (1802: 0x6N)</td><td>1</td></tr>
<tr><td>0xA</td><td>SEP Rn (1802: 0xDN)</td><td>1</td></tr>
<tr><td>0xB</td><td>SEX Rn (1802: 0xEN)</td><td>1</td></tr>
<tr><td>0xC</td><td>MUL/DIV</td><td>2</td></tr>
<tr><td>0xD</td><td>CSR read/write</td><td>2</td></tr>
<tr><td>0xE</td><td>MEX tile-ALU</td><td>1–3</td></tr>
<tr><td>0xF</td><td>EXT prefix</td><td>1 (+ following instruction)</td></tr>
</tbody>
</table>

<p>The tile load/store instructions (<code>LD1D</code>, <code>LD2D</code>, <code>ST1D</code>, <code>ST2D</code>, <code>PUSH</code>, <code>POP</code>,
<code>FILL</code>, <code>CLRROW</code>, <code>CLRCOL</code>, <code>INC.R</code>, <code>DEC.R</code>, <code>INC.C</code>, <code>DEC.C</code>, <code>SETW</code>,
<code>GETW</code>, <code>TILECPY</code>) are encoded within the <strong>MEX family (0xE)</strong> using the <code>TSYS</code>
sub-function space, since they are tile-engine operations that naturally belong alongside TALU/TMUL/TRED.
Cursor control (<code>INC.R</code>, <code>DEC.R</code>, etc.) can also be implemented as <code>CSRW</code> to the
<code>SR</code>/<code>SC</code> registers.</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="call-ret">4 Subroutine Call Mechanisms</h2>

<p>Megapad-64 provides <strong>two</strong> subroutine call/return mechanisms, honouring both the 1802's philosophy
and modern toolchain expectations:</p>

<h3>4.1 SEP-Based Call (1802 heritage)</h3>
<pre><code>; Caller side:
;   R4 points to subroutine entry
;   R3 is current PC (PSEL=3)
SEP R4        ; PSEL ← 4; execution continues at address in R4
              ; R3 still holds return address (instruction after SEP)

; Callee returns with:
SEP R3        ; PSEL ← 3; execution resumes in caller
</code></pre>
<p>This is identical to the 1802's <code>SEP</code> subroutine mechanism. For nested calls, the callee
uses <code>MARK</code> to save PSEL|XSEL to the stack, and <code>RET</code> to restore them.</p>

<h3>4.2 Stack-Based CALL/RET (modern convenience)</h3>
<pre><code>; Encoding: 0x0D (SYS family, N=0xD) followed by byte1
; Byte 1: 0000 | Rn   (Rn holds the target address)
CALL.L Rn     ; PUSH R(P)+2 to stack (return address); R(P) ← R(N)
              ; (Does NOT change PSEL — PC register stays the same)

; Return:
; Encoding: 0x0E (SYS family, N=0xE), 1 byte total
RET.L         ; POP return address from stack → R(P)
</code></pre>
<p><code>CALL.L</code> pushes the return address (address of instruction after CALL.L) onto the stack
via <code>R(SPSEL)</code>, then loads the target from <code>Rn</code> into the current PC register <code>R(P)</code>.
<code>RET.L</code> pops the stack into <code>R(P)</code>.</p>

<aside class="tip">
<strong>Design rationale:</strong> The 1802's <code>SEP</code> mechanism is elegant but consumes one register per active
call level. For deeply nested code and modern compiled languages, a stack-based CALL/RET is more
practical. Megapad-64 offers both — the programmer (or compiler) chooses. <code>SEP</code> remains ideal for
coroutine-like switching between short routines (its original 1802 use case).
</aside>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="ivec">5 Trap and Interrupt Vector Assignments (IVEC_ID)</h2>

<table>
<thead><tr><th>IVEC_ID</th><th>Source</th><th>Type</th></tr></thead>
<tbody>
<tr><td>0x00</td><td>Reset entry</td><td>System</td></tr>
<tr><td>0x01</td><td>NMI (non-maskable interrupt)</td><td>Interrupt</td></tr>
<tr><td>0x02</td><td>Illegal opcode trap</td><td>Trap</td></tr>
<tr><td>0x03</td><td>Alignment fault</td><td>Trap</td></tr>
<tr><td>0x04</td><td>Divide-by-zero</td><td>Trap</td></tr>
<tr><td>0x05</td><td>Bus fault (unmapped Megapad / external)</td><td>Trap</td></tr>
<tr><td>0x06</td><td>Software trap (<code>TRAP</code> instruction)</td><td>Trap</td></tr>
<tr><td>0x07</td><td>Privilege violation (reserved, never generated in v1.0)</td><td>Trap</td></tr>
<tr><td>0x08</td><td>Breakpoint (SWD debug)</td><td>Trap</td></tr>
<tr><td>0x09–0x0F</td><td><em>reserved for future traps</em></td><td>—</td></tr>
<tr><td>0x10</td><td>INT[0] — maskable interrupt line 0</td><td>Interrupt</td></tr>
<tr><td>0x11</td><td>INT[1]</td><td>Interrupt</td></tr>
<tr><td>0x12</td><td>INT[2]</td><td>Interrupt</td></tr>
<tr><td>0x13</td><td>INT[3]</td><td>Interrupt</td></tr>
<tr><td>0x14–0x1F</td><td><em>reserved for additional interrupt lines</em></td><td>—</td></tr>
<tr><td>0x20</td><td>DMA completion</td><td>Interrupt</td></tr>
<tr><td>0x21</td><td>Timer 0 overflow</td><td>Interrupt</td></tr>
<tr><td>0x22</td><td>Timer 1 overflow</td><td>Interrupt</td></tr>
<tr><td>0x23–0x3F</td><td><em>reserved for peripherals</em></td><td>—</td></tr>
</tbody>
</table>

<aside class="note">
<strong>1802 interrupt model:</strong> The 1802 has a single interrupt line that forces <code>P←1, X←2</code>.
Megapad-64 extends this to a vectored scheme but preserves the core idea: on interrupt entry, the
hardware saves the current designators (like the 1802's T register) and redirects PC through a table.
The <code>RET</code>/<code>DIS</code> instructions restore the designators, exactly as on the 1802.
</aside>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="flags-rules">6 FLAGS Update Rules Per Instruction Class</h2>

<table>
<thead><tr><th>Instruction class</th><th>Z</th><th>C</th><th>N</th><th>V</th><th>P</th><th>G</th><th>I</th><th>S</th></tr></thead>
<tbody>
<tr><td>ALU: ADD/ADC/SUB/SBB/NEG</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>ALU: AND/OR/XOR/NOT</td><td>✓</td><td>←0</td><td>✓</td><td>←0</td><td>✓</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>ALU: CMP</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>—</td><td>✓</td><td>—</td><td>—</td></tr>
<tr><td>ALU: MOV</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>Shift/Rotate: SHL/SHR/SAR</td><td>✓</td><td>✓ (last bit out)</td><td>✓</td><td>—</td><td>✓</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>Shift/Rotate: ROL/ROR</td><td>✓</td><td>—</td><td>✓</td><td>—</td><td>✓</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>IMM: ADDI/SUBI/CMPI</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓ (CMPI)</td><td>—</td><td>—</td></tr>
<tr><td>IMM: ANDI/ORI/XORI</td><td>✓</td><td>←0</td><td>✓</td><td>←0</td><td>✓</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>IMM: LDI/LHI</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>MEM: all loads/stores</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>MEMALU (0x8): all ops</td><td>✓</td><td>✓ (≡DF)</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>INC/DEC Rn</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>PUSH/POP</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>MUL/DIV</td><td>✓</td><td>—</td><td>✓</td><td>✓ (overflow)</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>MEX tile ops</td><td>✓ (reduction=0)</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>✓ (saturation)</td></tr>
<tr><td>BR/LBR/SKIP</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>SEP/SEX/MARK/SAV</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
<tr><td>RET</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>✓ (←1)</td><td>—</td></tr>
<tr><td>DIS</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td><td>✓ (←0)</td><td>—</td></tr>
<tr><td>RTI</td><td colspan="8">All flags restored from stack</td></tr>
</tbody>
</table>

<p>Legend: ✓ = updated from result; ←0 = forced to 0; ←1 = forced to 1; — = unchanged.</p>

<aside class="note">
<strong>1802 compatibility:</strong> The 1802's only flag was <code>DF</code> (data flag / carry). It was updated only by
arithmetic and shift instructions. Megapad-64's <code>FLAGS.C</code> is the spiritual successor of <code>DF</code>, and the
MEMALU family (0x8) updates only <code>Z</code> and <code>C</code> to mirror the 1802's minimal flag model.
</aside>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="push-pop">7 PUSH and POP Encoding</h2>

<p>Stack operations are encoded within the CTL space. Since they are among the most commonly used
instructions (function prologues/epilogues, interrupt handlers), they get compact encodings:</p>

<h3>7.1 PUSH/POP via CSRW to SPSEL-based stack</h3>
<p>PUSH and POP are 2-byte instructions in the MEM family:</p>
<div class="bit-diagram">
  PUSH Rs:   0101 | 0101   Rs|0000     ; MEM STXD variant: M(SP) ← Rs; SP -= 8
  POP  Rd:   0101 | 0011   Rd|0000     ; MEM LDXA variant: Rd ← M(SP); SP += 8
</div>
<p>Equivalently, they can be seen as <code>STXD</code> and <code>LDXA</code> operations on the stack pointer
register, using <code>SPSEL</code> instead of <code>XSEL</code>. The assembler emits these as aliases.</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="idle">8 IDLE Wakeup Conditions</h2>

<p>Mirroring the 1802's <code>IDL</code> (opcode 0x00), the Megapad-64 <code>IDL</code> instruction enters a
low-power idle state. The following events resume execution:</p>
<ul>
  <li>Any maskable interrupt (if <code>FLAGS.I = 1</code>)</li>
  <li>NMI (regardless of <code>FLAGS.I</code>)</li>
  <li>DMA request (<code>DMAREQ</code> assertion)</li>
  <li>External debug halt/resume via SWD</li>
</ul>
<p>The 1802 behaved identically: <code>IDL</code> waited for DMA-IN, DMA-OUT, or interrupt.</p>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="decode-summary">9 Decoder Quick Reference</h2>

<p>For an interpreter/emulator, the decode loop is:</p>

<pre><code>byte0 = fetch(R(P)); R(P) += 1
F = byte0 >> 4          // family nibble
N = byte0 & 0x0F        // operand nibble

switch (F) {
  case 0x0: /* SYS:    1 byte  — dispatch on N */                break;
  case 0x1: /* INC:    1 byte  — R(N) += 1 */                   break;
  case 0x2: /* DEC:    1 byte  — R(N) -= 1 */                   break;
  case 0x3: /* BR:     2 bytes — fetch offset byte */            break;
  case 0x4: /* LBR:    3 bytes — fetch 2 offset bytes */         break;
  case 0x5: /* MEM:    2 bytes — fetch Rd|Rs byte */             break;
  case 0x6: /* IMM:    2-4 bytes — depends on sub-op */          break;
  case 0x7: /* ALU:    2 bytes — fetch Rd|Rs byte */             break;
  case 0x8: /* MEMALU: 1 byte  — dispatch on N (1802 ALU) */     break;
  case 0x9: /* I/O:    1 byte  — dispatch on N */                break;
  case 0xA: /* SEP:    1 byte  — PSEL ← N */                    break;
  case 0xB: /* SEX:    1 byte  — XSEL ← N */                    break;
  case 0xC: /* MULDIV: 2 bytes — fetch Rd|Rs byte */             break;
  case 0xD: /* CSR:    2 bytes — fetch CSR addr byte */          break;
  case 0xE: /* MEX:    1-3 bytes — decode SS|Op, fetch funct */  break;
  case 0xF: /* EXT:    1 byte prefix — set modifier, re-fetch */ break;
}</code></pre>

<aside class="tip">
<strong>Key property:</strong> Instruction length is always determinable from the first byte alone (family nibble),
exactly as on the 1802. The 1802 was: 1 byte for most ops, 2 bytes for short branch and immediate,
3 bytes for long branch. Megapad-64 preserves this: 1 byte for simple ops, 2–3 for most others,
and the EXT prefix for the rare 64-bit immediate case.
</aside>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="1802-map">10 1802 → Megapad-64 Opcode Cross-Reference</h2>

<p>For programmers familiar with the 1802, here is a mapping of every 1802 opcode to its
Megapad-64 equivalent:</p>

<table>
<thead><tr><th>1802 Opcode</th><th>1802 Mnemonic</th><th>Megapad-64</th><th>Family</th></tr></thead>
<tbody>
<tr><td>00</td><td>IDL</td><td><code>IDL</code> (0x00)</td><td>SYS</td></tr>
<tr><td>0N (N≠0)</td><td>LDN N</td><td><code>LDN Rd, Rn</code> (0x50, byte1)</td><td>MEM</td></tr>
<tr><td>1N</td><td>INC N</td><td><code>INC Rn</code> (0x1N)</td><td>REG</td></tr>
<tr><td>2N</td><td>DEC N</td><td><code>DEC Rn</code> (0x2N)</td><td>REG</td></tr>
<tr><td>30-3F</td><td>BR/BZ/BNZ/BDF/BNF/BQ/BNQ/B1-B4…</td><td><code>BR.cond off8</code> (0x3C)</td><td>BR</td></tr>
<tr><td>4N</td><td>LDA N</td><td><code>LDA Rd, Rn</code> (0x51, byte1)</td><td>MEM</td></tr>
<tr><td>5N</td><td>STR N</td><td><code>STR Rn, Rs</code> (0x54, byte1)</td><td>MEM</td></tr>
<tr><td>60</td><td>IRX</td><td><code>IRX</code> (0x8E)</td><td>MEMALU</td></tr>
<tr><td>61-67</td><td>OUT 1-7</td><td><code>OUT N</code> (0x91–0x97)</td><td>I/O</td></tr>
<tr><td>69-6F</td><td>INP 1-7</td><td><code>INP N</code> (0x99–0x9F)</td><td>I/O</td></tr>
<tr><td>70</td><td>RET</td><td><code>RET</code> (0x05)</td><td>SYS</td></tr>
<tr><td>71</td><td>DIS</td><td><code>DIS</code> (0x06)</td><td>SYS</td></tr>
<tr><td>72</td><td>LDXA</td><td><code>LDXA</code> (0x8F)</td><td>MEMALU</td></tr>
<tr><td>73</td><td>STXD</td><td><code>STXD Rs</code> (0x55, byte1)</td><td>MEM</td></tr>
<tr><td>74</td><td>ADC</td><td><code>ADC.X</code> (0x88)</td><td>MEMALU</td></tr>
<tr><td>75</td><td>SDB</td><td><code>SDB.X</code> (0x89)</td><td>MEMALU</td></tr>
<tr><td>76</td><td>SHRC/RSHR</td><td><code>SHRC.D</code> (0x8A)</td><td>MEMALU</td></tr>
<tr><td>77</td><td>SMB</td><td><code>SMB.X</code> (0x8B)</td><td>MEMALU</td></tr>
<tr><td>78</td><td>SAV</td><td><code>SAV</code> (0x08)</td><td>SYS</td></tr>
<tr><td>79</td><td>MARK</td><td><code>MARK</code> (0x07)</td><td>SYS</td></tr>
<tr><td>7A</td><td>REQ</td><td><code>REQ</code> (0x0A)</td><td>SYS</td></tr>
<tr><td>7B</td><td>SEQ</td><td><code>SEQ</code> (0x09)</td><td>SYS</td></tr>
<tr><td>7C</td><td>ADCI</td><td><code>ADDI Rn, imm8</code> + carry (via EXT or MEMALU)</td><td>IMM/MEMALU</td></tr>
<tr><td>7D</td><td>SDBI</td><td><code>SUBI Rn, imm8</code> (via IMM family)</td><td>IMM</td></tr>
<tr><td>7E</td><td>SHLC/RSHL</td><td><code>SHLC.D</code> (0x8D)</td><td>MEMALU</td></tr>
<tr><td>7F</td><td>SMBI</td><td><code>SUBI</code> with borrow (via IMM)</td><td>IMM</td></tr>
<tr><td>8N</td><td>GLO N</td><td><code>GLO Rn</code> (0x6C, byte1=Rn)</td><td>IMM</td></tr>
<tr><td>9N</td><td>GHI N</td><td><code>GHI Rn</code> (0x6D, byte1=Rn)</td><td>IMM</td></tr>
<tr><td>AN</td><td>PLO N</td><td><code>PLO Rn</code> (0x6E, byte1=Rn)</td><td>IMM</td></tr>
<tr><td>BN</td><td>PHI N</td><td><code>PLO Rn</code> (0x6F, byte1=Rn)</td><td>IMM</td></tr>
<tr><td>C0-CF</td><td>LBR/LBNZ/LBDF…/NOP/LSKP/LSZ…</td><td><code>LBR.cond off16</code> (0x4C)</td><td>LBR</td></tr>
<tr><td>DN</td><td>SEP N</td><td><code>SEP Rn</code> (0xAN)</td><td>SEP</td></tr>
<tr><td>EN</td><td>SEX N</td><td><code>SEX Rn</code> (0xBN)</td><td>SEX</td></tr>
<tr><td>F0</td><td>LDX</td><td><code>LDX</code> (0x80)</td><td>MEMALU</td></tr>
<tr><td>F1</td><td>OR</td><td><code>OR.X</code> (0x81)</td><td>MEMALU</td></tr>
<tr><td>F2</td><td>AND</td><td><code>AND.X</code> (0x82)</td><td>MEMALU</td></tr>
<tr><td>F3</td><td>XOR</td><td><code>XOR.X</code> (0x83)</td><td>MEMALU</td></tr>
<tr><td>F4</td><td>ADD</td><td><code>ADD.X</code> (0x84)</td><td>MEMALU</td></tr>
<tr><td>F5</td><td>SD</td><td><code>SD.X</code> (0x85)</td><td>MEMALU</td></tr>
<tr><td>F6</td><td>SHR</td><td><code>SHR.D</code> (0x86)</td><td>MEMALU</td></tr>
<tr><td>F7</td><td>SM</td><td><code>SM.X</code> (0x87)</td><td>MEMALU</td></tr>
<tr><td>F8</td><td>LDI</td><td><code>LDI Rn, imm8</code> (0x60, byte1, byte2)</td><td>IMM</td></tr>
<tr><td>F9</td><td>ORI</td><td><code>ORI Rn, imm8</code> (0x64, byte1, byte2)</td><td>IMM</td></tr>
<tr><td>FA</td><td>ANI</td><td><code>ANDI Rn, imm8</code> (0x63, byte1, byte2)</td><td>IMM</td></tr>
<tr><td>FB</td><td>XRI</td><td><code>XORI Rn, imm8</code> (0x65, byte1, byte2)</td><td>IMM</td></tr>
<tr><td>FC</td><td>ADI</td><td><code>ADDI Rn, imm8</code> (0x62, byte1, byte2)</td><td>IMM</td></tr>
<tr><td>FD</td><td>SDI</td><td><code>SUBI Rn, imm8</code> (0x67, byte1, byte2)</td><td>IMM</td></tr>
<tr><td>FE</td><td>SHL</td><td><code>SHL.D</code> (0x8C)</td><td>MEMALU</td></tr>
<tr><td>FF</td><td>SMI</td><td><code>SUBI Rn, imm8</code> (reversed operand order via flag)</td><td>IMM</td></tr>
</tbody>
</table>

<!-- ═══════════════════════════════════════════════════════════════ -->
<h2 id="design-decisions">11 Key Design Decisions Summary</h2>

<ol>
<li><strong>Preserved <code>I|N</code> primary byte format</strong> — 4-bit family + 4-bit operand in byte 0, exactly
    as the 1802. A decoder switch on the high nibble is the entire first-level dispatch.</li>

<li><strong>Preserved <code>SEP</code>/<code>SEX</code> as full families</strong> — they each get their own F nibble (0xA, 0xB)
    with N=register, mirroring the 1802's 0xDN and 0xEN. This makes the 1802's most distinctive
    feature — register-as-PC switching — a first-class citizen rather than a buried encoding.</li>

<li><strong>Preserved the <code>D</code> accumulator and R(X)-indirect ALU path</strong> — the MEMALU family (0x8)
    is a complete 1802 ALU in one family, operating through D and M(R(X)) just like the original.
    This means 1802-style code can be written on Megapad-64 using families 0x0-0x3, 0x5, 0x8-0xB
    with almost the same opcode structure.</li>

<li><strong>Added register-to-register ALU (0x7) and scalar MEM (0x5) for modern use</strong> — compilers
    need these. They coexist with the 1802-heritage paths without conflict.</li>

<li><strong>Short/long branch mirrors 1802's 2/3-byte structure</strong> — condition in the first byte,
    offset in subsequent bytes. PC-relative instead of page-relative for 64-bit addressing.</li>

<li><strong><code>MARK</code>/<code>RET</code>/<code>DIS</code>/<code>SAV</code> preserved</strong> — the 1802's designator save/restore
    mechanism works identically, using the stack instead of R(2) hard-coded.</li>

<li><strong>EXT prefix is the "long instruction" mechanism</strong> — analogous to the 1802's 3-cycle
    long branch/long skip instructions. It's a controlled, documented cost — never ambiguous.</li>

<li><strong>Instruction length from byte 0 only</strong> — the decoder never needs to look ahead to
    determine instruction boundaries, exactly like the 1802.</li>

<li><strong>Tile and MEX ops consolidated in 0xE</strong> — keeps the scalar ISA close to the 1802's
    simplicity; the tile engine is its own world within one family.</li>

<li><strong>Single flat privilege model</strong> — like the 1802, which had no privilege levels.</li>
</ol>

<p class="legal" style="margin-top:3rem;font-size:.8rem;color:#57606a">
Megapad-64 Instruction Encoding Specification v0.1. Draft for interpreter/emulator development.
</p>

</body>
</html>
